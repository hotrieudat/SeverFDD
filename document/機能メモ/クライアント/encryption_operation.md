# 暗号化方法について

## 初めに
ファイルやメッセージの暗号化はopensslを利用する

## サーバー側が最低限保持すべきデータ

### ファイルテーブル

* ファイルID
* ファイル名
* パスワード

### ハッシュテーブル

* ファイルID
* ハッシュ

### ユーザーテーブル

* ユーザーID
* ユーザーの公開鍵

### リレーションシップ
* ファイルテーブル : ハッシュテーブル = 1 : n

## クライアント側が最低限保持すべきデータ

* ユーザーID
* ユーザーの秘密鍵

## 暗号化されたファイルが最低限保持するべきデータ(ファイル先頭にでも記述する)

* ファイルID

## 暗号化手順

通信はHTTPで行い、認証情報の維持はSessionで行うものとする
ファイルの識別子に関しては、[暗号化ファイル仕様について](./binary_format.md)を参照
ロギング処理は省略している

1. クライアント側、ユーザーIDとログイン用のパスワードを使って、サーバーと認証を行う(詳細は省略)
2. クライアント側、ファイル名を送信する ([通信1-1](#1-1)ここから)
3. サーバー側、ファイル名を受け取る
4. サーバー側、ファイルIDとファイル暗号化用パスワードを自動生成し、ファイル名とともにDBに登録
   ファイルIDはセッションに保存する
5. サーバー側、ファイル暗号化用パスワードを[AES256-ECB](#AES256) を使って暗号化し、ファイルIDと共に送信([通信1-1](#1-1)ここまで)
6. クライアント側、ファイルIDとファイル暗号化用パスワードを[AES256-ECB](#AES256) を使って復号化する
7. クライアント側、復号かしたファイル暗号化用パスワードを使ってファイルを暗号化する
8. クライアント側、暗号化ファイルの先頭にファイルの識別子をつける
9. クライアント側、生成されたファイルのハッシュを計算し、サーバーに送信する([通信1-2](#1-2)ここから)
10. サーバー側、受信したファイルのハッシュを、セッションに保存されたファイルIDとひも付け、DBに保存する
11. サーバー側、クライアントに成功通知を行い終了([通信1-2](#1-2)ここまで)

<a name="AES256"></a>
### AES256-ECB暗号化手順

1. ユーザーIDと、sha256ハッシュ化されたユーザーPWを結合し、更にsha256でハッシュ化
2. 1．にて作成した、ハッシュ値の先頭から256文字（要検証）を取得
3. 暗号化ファイル用のパスワードを 2．にて取得した文字列を利用してAES256-ECBにて暗号化する


## 復号化手順

通信はHTTPで行い、認証情報の維持はSessionで行うものとする
ロギング処理は省略している

1. クライアント側、ユーザーIDを使って、サーバーと認証を行う(詳細は省略)
2. クライアント側、暗号化されたファイルのハッシュを計算する
3. クライアント側、暗号化されたファイルの先頭からファイルIDを読み取る
4. クライアント側、ハッシュとファイルIDをサーバーに送信する
5. サーバー側、ハッシュ及びファイルIDから該当ファイルレコードを検索する
6. ※ハッシュを用いるのは、ファイルIDを偽装して送信されることへの対策である
7. サーバー側、パスワードをAES256で暗号化し送信する[AES256-ECB暗号化手順](#AES256)
8. クライアント側、パスワードを受け取り復号化する

## ファイル編集手順

通信はHTTPで行い、認証情報の維持はSessionで行うものとする
ロギング処理は省略している

1. クライアント側、ユーザーIDを使って、サーバーと認証を行う(詳細は省略)
2. クライアント側、上記「復号化手順」に沿って復号化を行う その際、ファイルIDを記憶しておく
3. クライアント側、復号されたファイルを使って編集を行う
4. クライアント側、ファイルを保存する(以下編集済み生ファイルとする)
5. クライアント側、編集済み生ファイルを保存する際、再度暗号化を行う ファイルIDと新しいハッシュをサーバー側に送信する
6. サーバー側、ファイルIDと新しいハッシュをひも付け、ハッシュテーブルに保存する (ファイルIDと新しいハッシュは一対多の関係)

## ~~オフライン用暗号化~~
2017/08/08　本実装に関しては見送り

通信はHTTPで行い、認証情報の維持はSessionで行うものとする
ロギング処理は省略している

1. クライアント側、ユーザーIDと自身の秘密鍵を使って、サーバーと認証を行う(詳細は省略)
2. クライアント側、ファイル名、及びデコードを許可したいユーザーリストを送信する
3. サーバー側、ファイル名およびデコードを許可したいユーザーリストを受信する
4. サーバー側、ファイルIDとパスワードを自動生成し、ファイル名とともにDBに登録
   ファイルIDはセッションに保存する
5. サーバー側、ログインユーザーの公開鍵を使ってパスワードを暗号化する(以下暗号化パスワード)
6. サーバー側、許可したいユーザーの各々の公開鍵でパスワードを暗号化したもの(以下暗号化パスワードリスト)を生成する 以下擬似コード
```php
$encoded_password_list = [];
foreach ($users as $user) {
    encoded_password_list[] = encode($raw_password, $user->public_key);
}
return $encoded_password_list
```
7. 暗号化パスワード、暗号化パスワードリスト、ファイルIDを送信する
8. クライアント側、暗号化パスワードを自身の秘密鍵を使って復号化する(以下生パスワード)
9.  クライアント側、生パスワードを使ってファイルを暗号化する
10. クライアント側、ファイルIDと暗号化パスワードリストを暗号化ファイルの先頭に書き込む
11. クライアント側、生成された暗号化ファイルのハッシュを計算し、サーバーに送信する
12. サーバー側、受信したファイルのハッシュを、セッションに保存されたファイルIDとひも付け、DBに保存する
13. サーバー側、クライアントに成功通知を行い終了

## ~~オフライン復号化~~
2017/08/08　本実装に関しては見送り

以下は当然全てクライアント側の処理である

1. 暗号化されたファイルの先頭より、暗号化パスワードリストを切り出す
2. 自身の秘密鍵を用い、暗号化パスワードリストを順に復号化していく
3. いずれかのタイミングで復号化に成功するはずである(復号化で得られたパスワードを以下生パスワードとする)
4. 暗号化ファイルより、ファイルIDと暗号化パスワードリストを分離する（以下純暗号化ファイル）
5. 純暗号化ファイルを、生パスワードを使って復号化する

## HTTP通信仕様
基本的に送信時・受信ともにJSONで行う 文字コードはUTF-8  
また、成否の通知はHTTPステータスコードで行うこととする 2xxで成功、4xxで失敗である  
※2017/08/08時点では、PloResultの標準機能を利用しているため、statusで判定している。  
(参考: http://qiita.com/uenosy/items/ba9dbc70781bddc4a491)

### 暗号化通信
<a name="1-1"></a>

#### 通信1-1
* サーバーURL
    - API/File/Create-File-Password
* 送信
    - name : ファイル名
* 受信
    - 成功時
        {"status" : true, "custom_data": {"file_id": ファイルID, "password": パスワードを[AES256-ECB](#AES256)にて暗号化、さらにbase64エンコードされたパスワード }
        ※opensslで暗号化されたテキストはバイナリ形式となるため、取り扱いやすいようbase64エンコードするものとする}}
    - 失敗時
        {"status": false, "message": "失敗時のメッセージ"}

<a name="1-2"></a>
#### 通信1-2
* サーバーURL
    - API/Hash/Register-Hash
* 送信
    - file_id: サーバーに登録したファイルID
    - hash: 暗号化されたファイルのハッシュ ハッシュは16進数表記とする
* 受信
    - 成功時
        {"status": true}
    - 失敗時
        {"status": false, "message": "失敗時のメッセージ"}
